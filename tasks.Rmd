---
title: "Домашнее задание 4"
output: html_document
author: "Grivachev Mstislav"
---

Большинство задач в домашнем задании по R предполагают автоматическое тестирование решений. Один тест представляет собой блок кода, который возвращает значение TRUE, если тест пройден, и значение FALSE, если тест не пройден. Если какие-то тесты не пройдены, выводится ошибка вида `[something] не TRUE`. Перед каждым тестом приводятся пояснения, которые помогают понять, что именно не так с решением.

1. Если у вас **успешно** установились библиотеки `devtools` и `testrmd`:

    ```{r, eval = FALSE}
    install.packages("devtools")
    devtools::install_github("ropenscilabs/testrmd", force = TRUE)
    ```

    можете убрать опцию `eval=FALSE` в ячейке ниже, связывать Rmd-файл в html и смотреть на выполнение тестов. При связывании текущего Rmd-файла в готовом html-файле отображаются включения с информацией о пройденных тестах. Если какие-то тесты не пройдены, рядом с блоком с решением задачи появляется красная кнопка, а в начале файла появляется предупреждение вида `Warning! This document contains N failing tests`. Можно кликнуть на красную кнопку и посмотреть, какие тесты не пройдены и почему.

```{r}
testrmd::init()
```


2. Если библиотеки `devtools` и `testrmd` **не установились**, запускайте строки в ячейке с тестами как обычный код и проверяйте, пройден ли тест. Если после запуска ячейки с тестом не выводится сообщение об ошибке, тест пройден. 


## Задача 1

Два события $A$ и $B$ являются независимыми, если выполняется условие $P(A \cap B) = P(A) \times P(B)$. Напишите код, который запрашивает у пользователя с клавиатуры вероятности событий $A$ и $B$ и вероятность их пересечения (одна вероятность — один ввод) и проверяет, являются ли события $A$ и $B$ независимыми, то есть сохраняет и выводит на экран логическое значение `TRUE` или `FALSE`.

**Пример 1**

```
Enter P(A): 0.4
Enter P(B): 0.5
Enter P(A and B): 0.2
[1] TRUE
```

**Пример 2**

```
Enter P(A): 0.3
Enter P(B): 0.1
Enter P(A and B): 0.2
[1] FALSE
```

```{r code1}
probs <- function(){
  ### BEGIN YOUR CODE
  A <- as.numeric(readline(prompt = "input A "))
  B <- as.numeric(readline(prompt = "input B "))
  I <- as.numeric(readline(prompt = 'input intersection A and B '))
  print(I == A*B)
  ### END YOUR CODE
}
probs()
```

**Тесты:** 

Если тест не пройден, то ваш код не выводит значение типа `logical`.

```{r test_chunk1, test = TRUE}
test.1 <- probs()
stopifnot(is.logical(test.1), TRUE)
```

## Задача 2

Напишите код, который запрашивает у пользователя с клавиатуры значения дискретной случайной величины через пробел, потом запрашивает соответствующие значениям вероятности через пробел, и выводит на экран математическое ожидание и дисперсию этой величины.

**Пример**

```
Enter values: -1 0 3
Enter probabilities: 0.4 0.1 0.5
E(X) = 1.1 and D(X) = 3.69
```

**Напоминание.** Математическое ожидание — ожидаемое среднее значение случайной величины — вычисляется следующим образом:

$$
E(X)=\sum\limits_{i=1}^{n}x_ip_i = x_1p_1 + x_2p_2 + \dots + x_np_n.
$$

Другими словами, перемножаем значения и соответствующие им вероятности, а потом все суммируем).

Дисперсия — показатель разброса значений случайной величины относительно ожидаемого среднего значения — вычисляется следующим образом:

$$
D(X)=E(X^2)-[E(X)]^2.
$$
```{r code2}
discreteV <- function(){
  ### BEGIN YOUR CODE
  vl <- as.numeric(unlist(strsplit(readline(prompt = "Values: "), split = ' ')))
  pbs <- as.numeric(unlist(strsplit(readline(prompt = "Probs:  "), split = ' ')))
  E <- sum(vl*pbs)
  D <- sum((vl**2)*pbs) - E**2
  cat(sprintf("E =  %.4f, D = %.4f", E, D))
  ### END YOUR CODE
}
discreteV()
```

## Задача 3

Число действительных бюллетеней на избирательных участках некоторой территориальной избирательной комиссии задается вектором `valid_votes`, а число недействительных бюллетеней — вектором `invalid_votes`. Общее число зарегистрированных избирателей задается вектором `voters`.

```{r}
valid_votes <- c(25, 8, 12, 18, 25, 32, 10, 17, 22, 17)
invalid_votes <- c(1, 0, 4, 3, 9, 2, 0, 5, 1, 0)
voters <- c(50, 75, 62, 54, 98, 55, 72, 80, 44, 48)
```

Создайте вектор `turnout`, который содержит значения явки на избирательных участках, выраженные в процентах и округленные до *второго* знака после запятой.

**Напоминание.** Явка определяется как доля суммы действительных и недействительных бюллетеней от общего числа зарегистрированных избирателей.

```{r code3}
get.turn <- function(){
  valid_votes <- c(25, 8, 12, 18, 25, 32, 10, 17, 22, 17)
  invalid_votes <- c(1, 0, 4, 3, 9, 2, 0, 5, 1, 0)
  voters <- c(50, 75, 62, 54, 98, 55, 72, 80, 44, 48)
  turnout <- c()
  ### BEGIN YOUR CODE
  turnout<-round(((valid_votes+invalid_votes)/voters)*100, digits = 2)
  ### END YOUR CODE
  turnout
}
get.turn()
```

**Тесты:**

Если тест ниже не пройден, вектор содержит неверное число элементов.

```{r test_chunk3.1, test = TRUE, echo = FALSE}
test.3 <- get.turn()
stopifnot(length(test.3) == 10, TRUE)
```

Если тесты ниже не пройдены, вектор содержит неверные значения.

```{r test_chunk3.2, test = TRUE, echo = FALSE}
stopifnot(min(test.3) == 10.67, TRUE)
```

```{r test_chunk3.3, test = TRUE, echo = FALSE}
stopifnot(sum(test.3) == 352.96, TRUE)
```

## Задача 4

Вектор `ages` представляет собой набор значений возраста респондентов мужского пола, принимавших участие в опросе.

```{r}
ages <- c(23, 18, 19, 33, 36, 27, 68, 62, 78, 45, 42, 38, 55, 16, 14, 17, 92)
```

1. Выберите из вектора `ages` значения, которые соответствуют трудоспособному возрасту (в России для мужчин — с 16 до 59 лет включительно), и сохраните их в вектор `work_age`. Сколько людей такого возраста среди наших респондентов? Сохраните ответ на вопрос в переменную `N1`.

```{r code4.1}
demog1 <- function(){
  ages <- c(23, 18, 19, 33, 36, 27, 68, 62, 
            78, 45, 42, 38, 55, 16, 14, 17, 92)
  ### BEGIN YOUR CODE HERE
  work_age <- ages[ages >= 16 & ages <= 59]
  N1 = length(work_age)
  ### END YOUR CODE HERE
  N1
}
demog1()
```

**Тесты:**

Если тест ниже не пройден, ответ в `N1` неверный.

```{r test_chunk4.1, test = TRUE, echo = FALSE}
test.4.1 <- demog1()
stopifnot(test.4.1 == 12, TRUE)
```


2. Выберите из вектора `ages` значения, которые соответствуют возрасту, младше трудоспособного (в России — менее 16 лет), и сохраните их в вектор `young_age`. Сколько людей такого возраста среди наших респондентов? Сохраните ответ на вопрос в переменную `N1`.

**Тесты:**

Если тест ниже не пройден, ответ в `N2` неверный.

```{r code4.2}
demog2 <- function(){
  ages <- c(23, 18, 19, 33, 36, 27, 68, 62, 
            78, 45, 42, 38, 55, 16, 14, 17, 92)

  ### BEGIN YOUR CODE HERE
  young_age <- ages[ages <  16]
  N2 <- length(young_age)
  ### END YOUR CODE HERE
  N2
}
demog2()
```

```{r test_chunk4.2, test = TRUE, echo = FALSE}
test.4.2 <- demog2()
stopifnot(test.4.2 == 1, TRUE)
```

## Задача 5

Политолог Мебейн (Walter R. Mebane) считает, что большая доля избирательных участков со значениями явки, заканчивающихся на 0 или 5, свидетельствует о фальсификациях результатов выборов. Аргументирует он это чисто психологическими причинами: если значения явки сочиняют люди, то они более склонны записывать круглые числа и числа, кратные 5.

Перед вами вектор значений явки на избирательных участках в районе F страны Флатландии:

```{r}
Fturnout <- c(100, 124, 121, 130, 150, 155, 144, 132, 189, 145, 125, 110, 118, 129, 127)
```

Сохраните в вектор `s` индексы избирательных участков, где явка, согласно Мебейну, выглядит подозрительной.

```{r code5}
suspect1 <- function(){
  Fturnout <- c(100, 124, 121, 130, 150, 155, 
                144, 132, 189, 145, 125, 110, 118, 129, 127)
  s <- which(Fturnout%%5 == 0)
  s
}
suspect1()
```


**Тесты:**

Если тест ниже не пройден, вектор `s` содержит неверное число элементов.

```{r test_chunk5.1, test = TRUE, echo = FALSE}
test5 <- suspect1()
stopifnot(length(test5) == 7, TRUE)
```

Если тест ниже не пройден, вектор `s` содержит неверные элементы.

```{r test_chunk5.2, test = TRUE, echo = FALSE}
stopifnot(sum(test5) == 49, TRUE)
```

## Задача 6

Известно, что в таблице содержатся показатели по Ивановской области за 8 лет (с 2008 по 2015 включительно). В Ивановской области 21 муниципальный район. Создайте три вектора, которые могут быть использованы в качестве столбцов `region` (название области), `district_id` (номер района) и `year` (год):

а) считая, что сначала идут значения показателей по одному району за 8 лет, потом — по второму за 8 лет и так далее;

```{r code6.1}
ivanovo.a <- function(){
  region <- c()
  district_id <- c()
  year <- c()
  
  ### BEGIN YOUR CODE
  region <- c('Ивановская область')
  year <- seq(from = 2008, to = 2015, by = 1)
  district_id <- seq(from = 1, to = 21, by = 1)
  region <- rep(region, each = 168)
  year <- rep(year, 21)
  district_id <- rep(district_id, each = 8)
  
  ### END YOUR CODE
  list(region = region, 
       district_id = district_id, 
       year = year)
}
ivanovo.a()
```

**Тесты:**

Если тесты ниже не пройдены, векторы `region`, `district_id`, `year` содержат неверное число элементов.

```{r test_chunk6a.1, test = TRUE, echo = FALSE}
test.6.1 <- ivanovo.a()

stopifnot(length(test.6.1$region) == length(test.6.1$district_id), TRUE) 
stopifnot(length(test.6.1$district_id) == length(test.6.1$year), TRUE)
stopifnot(length(test.6.1$year) == 168, TRUE)
```

Если тесты ниже не пройдены, векторы `region`, `district_id`, `year` содержат неверные элементы.

```{r test_chunk6a.2, test = TRUE, echo = FALSE}
stopifnot(length(unique(test.6.1$region)) == 1, TRUE)
stopifnot(length(unique(test.6.1$district_id)) == 21, TRUE)
stopifnot(test.6.1$district_id[22] == 3 & test.6.1$district_id[70] == 9, TRUE)
stopifnot(length(unique(test.6.1$year)) == 8, TRUE)
stopifnot(test.6.1$year[65] == 2008 & test.6.1$year[14] == 2013, TRUE)
```

б) считая, что сначала идут значения показателей по одному году по всем 21 районам, потом — по второму по 21 районам и так далее.

```{r code6.2}
ivanovo.b <- function(){
  region <- c()
  district_id <- c()
  year <- c()
  ### BEGIN YOUR CODE
  
  region <- c('Ивановская область')
  year <- seq(from = 2008, to = 2015, by = 1)
  district_id <- seq(from = 1, to = 21, by = 1)
  
  
  region <- rep(region, each = 168)
  year <- rep(year, each = 21)
  district_id <- rep(district_id, 8)
  
  ### END YOUR CODE
  list(region = region, district_id = district_id, year = year)
}
ivanovo.b()
```

**Тесты:**

Если тесты ниже не пройдены, векторы `region`, `district_id`, `year` содержат неверное число элементов.

```{r test_chunk6b.1, test = TRUE, echo = FALSE}
test.6.2 <- ivanovo.b()

stopifnot(length(test.6.2$region) == length(test.6.2$district_id), TRUE) 
stopifnot(length(test.6.2$district_id) == length(test.6.2$year), TRUE)
stopifnot(length(test.6.2$year) == 168, TRUE)
```

```{r test_chunk6b.2, test = TRUE, echo = FALSE}
stopifnot(length(unique(test.6.2$region)) == 1, TRUE)
stopifnot(length(unique(test.6.2$district_id)) == 21, TRUE)
stopifnot(test.6.2$district_id[22] == 1 & test.6.2$district_id[70] == 7, TRUE)
stopifnot(length(unique(test.6.2$year)) == 8, TRUE)
stopifnot(test.6.2$year[65] == 2011 & test.6.2$year[14] == 2008, TRUE)
```

## Задача 7

Создайте матрицу `M`, которая содержит данные по четырем городам (город, численность населения, площадь):

```
Москва, 12 615 279 человек, 2561.5 кв. км
Санкт-Петербург, 5 383 890 человек, 1439 кв. км
Омск, 1 164 815 человек, 566.9 кв. км
Екатеринбург, 1 483 119 человек, 468 кв. км
```

Обратите внимание: в матрице обязательно должны присутствовать названия городов, но при этом числовые данные должны иметь тип `numeric`.

```{r rcode7}
cities <- function(){
  
  ### BEGIN YOUR CODE
  M <- matrix(0, nrow =4 , ncol = 2)
  M<-cbind(as.numeric(c(12615279, 5383890,1164815,1483119)), as.numeric(c(2561.5, 1439, 566.9, 468)))
  rownames(M) <- c('Москва', "Санкт-Петербург", "Омск", "Екатеринбург")
  colnames(M) <- c('citizens', 'square')
  ### END YOUR CODE
  M
}
cities()
```

**Тесты:**

Если тест ниже не пройден, матрица имеет неверную размерность.

```{r test_chunk7.1, test = TRUE, echo = FALSE}
test.7 <- cities()
stopifnot(nrow(test.7) == 4 & ncol(test.7) == 2, TRUE)
```

Если тест ниже не пройден, матрица не является числовой.

```{r test_chunk7.2, test = TRUE, echo = FALSE}
stopifnot(is.numeric(test.7), TRUE)
```

Если тест ниже не пройден, матрица содержит неверные элементы.

```{r test_chunk7.3, test = TRUE, echo = FALSE}
stopifnot(test.7[1, 1] == 12615279 & test.7[3, 2] == 566.9, TRUE)
```

## Задача 8

Напишите код, который принимает на вход числовую матрицу `Nums` (дана в коде для примера) и сохраняет в переменную `rmax` индекс строки, имеющей наибольшую сумму элементов. Если таких строк несколько, то переменная `rmax` будет представлять собой вектор и хранить несколько индексов. 

Ваш код должен корректно работать для матрицы любой размерности. В задаче нельзя использовать условные конструкции и циклы.

**Подсказка.** Для нахождения суммы по каждой строке матрицы в R есть готовая функция `rowSums()`.

```{r code8}
Nums <- matrix(1:12, ncol = 5, byrow = TRUE)

sumsM <- function(Nums){
  rmax <- which((max(rowSums(Nums))) == rowSums(Nums))
  rmax
}
sumsM(Nums)
```

**Тесты:**

Если тесты ниже не пройдены, ваш код работает некорректно для матриц, в которых встречается ровно одна строка с максимальной суммой.

```{r test_chunk8.1, test = TRUE, echo = FALSE}
stopifnot(sumsM(matrix(1:7)) == 7, TRUE)
stopifnot(sumsM(matrix(20:35, ncol = 4)) == 4, TRUE)
```

Если тест ниже не пройден, ваш код работает некорректно для матриц, в которых встречается несколько строк с максимальной суммой.

```{r test_chunk8.2, test = TRUE, echo = FALSE}
stopifnot(sumsM(matrix(rep(1:6, 8), ncol=12)) == c(2, 4), TRUE)
```

## Задача 9

Дан список `Q` с характеристиками мячей для игры в квиддич. Напишите код, который добавит в этот список данные по снитчу: 

* name: snitch, 
* points: 150, 
* who_is_after: seeker.

```{r code9}
quidditch <- function(){
  Q <- list(name = c("quaffle", "bludger"),
  points = c(10, 0),
  who_is_after = c("chaser", "beater"))
  
  ### BEGIN YOUR CODE
  Q[[1]][3] <- 'snitch'
  Q[[2]][3] <- 150
  Q[[3]][3] <- 'seeker'
  ### END YOUR CODE
  Q
}
quidditch()
```

**Тесты:**

Если тесты ниже не пройдены, список `Q` или векторы в нем имеют неверное число элементов.

```{r test_chunk9.1, test = TRUE, echo = FALSE}
test.9 <- quidditch()
stopifnot(length(test.9) == 3, TRUE)
stopifnot(length(test.9$name) == 3 & length(test.9$points) == 3 & length(test.9$who_is_after) == 3, TRUE)
```

Если тесты ниже не пройдены, список `Q` содержит неверные элементы.

```{r test_chunk9.2, test = TRUE, echo = FALSE}
stopifnot(test.9$name[3] == 'snitch' & test.9$points[3] == 150 & test.9$who_is_after[3] == 'seeker', TRUE)
```

